namespace Chrono {

    //------------------------------------------------------------------------------

    class Date {
    public:
        enum Month {
            jan = 1, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec
        };

        class Invalid { };                 // to throw as exception

        Date(int y, Month m, int d);       // check for valid date and initialize
        Date();                            // default constructor
        // the default copy operations are fine

        // non-modifying operations:
        int   day()   const { return d; }
        Month month() const { return m; }
        int   year()  const { return y; }

        // modifying operations:
        void add_day(int n);
        void add_month(int n);
        void add_year(int n);
    private:
        int   y;
        Month m;
        int   d;
    };

    //------------------------------------------------------------------------------

    bool is_date(int y, Date::Month m, int d); // true for valid date

    //------------------------------------------------------------------------------

    bool leapyear(int y);                  // true if y is a leap year

    //------------------------------------------------------------------------------

    bool operator==(const Date& a, const Date& b);
    bool operator!=(const Date& a, const Date& b);

    //------------------------------------------------------------------------------

    ostream& operator<<(ostream& os, const Date& d);
    istream& operator>>(istream& is, Date& dd);

    //------------------------------------------------------------------------------

} // Chrono

//------------------------------------------------------------------------------

//The definitions go into Chrono.cpp:

// Chrono.cpp

namespace Chrono {

    // member function definitions:

    //------------------------------------------------------------------------------

    Date::Date(int yy, Month mm, int dd)
        : y(yy), m(mm), d(dd)
    {
        if (!is_date(yy, mm, dd)) throw Invalid();
    }

    //------------------------------------------------------------------------------

    const Date& default_date()
    {
        static const Date dd(2001, Date::jan, 1); // start of 21st century
        return dd;
    }

    //------------------------------------------------------------------------------

    Date::Date()
        :y(default_date().year()),
        m(default_date().month()),
        d(default_date().day())
    {
    }

    //------------------------------------------------------------------------------

    void Date::add_day(int n)
    {
        if (n < 1 or n>31)
            throw Invalid{ };
       
        d += n;
    }

    //------------------------------------------------------------------------------

    void Date::add_month(int n)
    {
        m = (m == Date::Month::dec) ? Month::jan : Month(int(m) + 1);
        // ..
        if (m == Date::Month::jan) add_year(1);

    }   

    //------------------------------------------------------------------------------

    void Date::add_year(int n)
    {
        if (m == feb && d == 29 && !leapyear(y + n)) { // beware of leap years!
            m = mar;        // use March 1 instead of February 29
            d = 1;
        }
        y += n;
    }

    //------------------------------------------------------------------------------

    // helper functions:

    bool year_is_valid(int y) // return true if date is valid
    {
        if (y < 1900 || 3000 < y) return false;
        // . . .
    }


    bool is_date(int y, Date::Month  m, int d)
    {
        // assume that y is valid
        if (!year_is_valid(y)) return false;
        if (d <= 0) return false;            // d must be positive

        int days_in_month = 31;            // most months have 31 days

        switch (m) {
        case Date::feb:                        // the length of February varies
            days_in_month = (leapyear(y)) ? 29 : 28;
            break;
        case Date::apr: case Date::jun: case Date::sep: case Date::nov:
            days_in_month = 30;                // the rest have 30 days
            break;
        }

        if (days_in_month < d) return false;

        return true;
    }

    //------------------------------------------------------------------------------

    bool leapyear(int y)
    {
       if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))    
       return true; 
           
       return false;
    }

    //------------------------------------------------------------------------------

    bool operator==(const Date& a, const Date& b)
    {
        return a.year() == b.year()
            && a.month() == b.month()
            && a.day() == b.day();
    }

    //------------------------------------------------------------------------------

    bool operator!=(const Date& a, const Date& b)
    {
        return !(a == b);
    }

    //------------------------------------------------------------------------------

    ostream& operator<<(ostream& os, const Date& d)
    {
        return os << '(' << d.year()
            << ',' << d.month()
            << ',' << d.day()
            << ')';
    }

    //------------------------------------------------------------------------------

    istream& operator>>(istream& is, Date& dd)
    {
        int y, m, d;
        char ch1, ch2, ch3, ch4;
        is >> ch1 >> y >> ch2 >> m >> ch3 >> d >> ch4;
        if (!is) return is;
        if (ch1 != '(' || ch2 != ',' || ch3 != ',' || ch4 != ')') { // oops: format error
            is.clear(ios_base::failbit);                    // set the fail bit
            return is;
        }
        dd = Date(y, Date::Month(m), d);     // update dd
        return is;
    }

    //------------------------------------------------------------------------------

    enum Day {
        sunday, monday, tuesday, wednesday, thursday, friday, saturday
    };

    //------------------------------------------------------------------------------

    int find_index(int y, Date::Month m, int d) {
        int year_sum{ 0 };
        int month_sum { 0 };

        for (int i = 1900; i < y; ++i) {

            if (leapyear(i)) year_sum += 366;
            else year_sum += 365;
            }

        for (int i = 0; i < int(m); ++i) {

            switch (i) {
            case 2:                        // the length of February varies
                month_sum += (leapyear(y)) ? 29 : 28;
                break;
            case 4: case 6: case 9: case 11:
                month_sum += 30;             // the rest have 30 days
                break;
                month_sum += 31;
            }

        }

        return year_sum + month_sum + d;
    }

    Day day_of_week(const Date& d)
    {
        
        int index = find_index(d.year(), d.month(), d.day());
        // ...
        int y = index % 7;
        int day_index = int(Day::monday);
        for (int i = 1; i < (y + 1); ++i) {

            if (day_index == 7) { day_index = 0; }
            ++day_index;

        }
        
        return Day(day_index);
    }

    //------------------------------------------------------------------------------
    

    //------------------------------------------------------------------------------
    Date next_Sunday(const Date& d)
    {
        int new_year{ 0 };
        Date::Month new_m;
        Day current = day_of_week(d);
        int sunday = 0;
        int day_count{ 0 };
        int week_count = int(current);
        while (true) {

            if (week_count == 7) {week_count = 0; ++sunday; }
                ++week_count;
                ++day_count;
            if (sunday == 2) break;
        }
        int diff = day_count + d.day();

        if (diff > 31) {

            switch (d.month()) {
            case Date::dec:
                new_year = d.year() + 1; new_m = Date::jan;
                break;
                new_m = Date::Month(int(d.month()) + 1);
            }
            int rem_days{ 0 };
            switch (d.month()) {
            case Date::feb:                        // the length of February varies
                int x = (leapyear(d.year())) ? 29 : 28; rem_days = x - d.day() - day_count;
                break;
            case Date::apr: case Date::jun: case Date::sep: case Date::nov:
                rem_days = 30 - d.day() - day_count;            // the rest have 30 days
                break;
                rem_days = 31 - d.day() - day_count;
            }

            return Date{ new_year, new_m, rem_days };

        }
        else return Date{ d.year(), d.month(), diff };
        

    }

    //------------------------------------------------------------------------------

    Date next_weekday(const Date& d)
    {
        int next_day;
        Day current = day_of_week(d);

        if (current == Day::saturday || current == Day::sunday) {

            switch (current) {
            case Day::saturday:                        // the length of February varies
                month_sum += (leapyear(y)) ? 29 : 28;
                break;
            case Day::sunday:
                month_sum += 30;             // the rest have 30 days
                break;
                month_sum += 31;
            }
            // ...
            return d;
        }
    }
    //------------------------------------------------------------------------------

} // Chrono

//------------------------------------------------------------------------------

int main()
try
{
    Chrono::Date holiday(2005, Chrono::Date::dec, 28);// initialization
    
    Chrono::Date d2 = Chrono::next_Sunday(holiday);
    //Chrono::Date d2 = holiday;
    Chrono::Day  d = day_of_week(d2);
    holiday.add_month(1);
    holiday.add_year(1);
    cout << "holiday is " << holiday << " d2 is " << d2 << endl;
    return holiday != d2;
}
catch (Chrono::Date::Invalid&) {
    cerr << "error: Invalid date\n";
    return 1;
}
catch (...) {
    cerr << "Oops: unknown exception!\n";
    return 2;
}
