ostream& operator<<(ostream& os, const Book& d)
{
    return os << "title: " << d.title_get() <<"\n"
        << "author: " << d.author_get() << "\n"
        << "ISBN: " << d.ISBN_get() << "\n"
        << "copyright date: " << d.copyright_get() << "\n"
        << "genre: " << genre_name(d) << "\n";
}

//------------------------------------------------------------------------------

istream& operator>>(istream& is, Book& dd)
{
    cout << "Enter title: ";
    string t;
    is >> t;
    cout << "Enter author: ";
    string a;
    is >> a;
    cout << "Enter date: ";
    Date copy;
    is >> copy;
      
    if (!is)  {
        is.clear(ios_base::failbit);                    
        return is;
    }

    dd = Book(t, a, copy);   // update dd
    return is;
}


https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading?noredirect=1&lq=1


operator->() is actually extremely weird. It's not required to return a value_type* -- 
in fact, it can return another class type, provided that class type has an operator->(), 
which will then be called subsequently. This recursive calling of operator->()s proceeds 
until a value_type* return type occurs. Madness! :)



OVERLOADING OSTREAM OPERATOR FOR STD VECTOR

template<class T> std::ostream& operator<<(std::ostream& os, const std::vector<T>& v)
{
	os << "{";
	for (int i = 0; i < v.size() - 1; ++i)
		os << ' ' << v[i] << ',';
	os << ' ' << v[v.size() - 1] << " }";
	return os;
}

 std::ostream& operator<<(std::ostream& os, const std::vector<double>& v)
{
	os << "[";
	for (int i = 0; i < v.size() - 1; ++i)
		os << ' ' << v[i] << ',';
	os << ' ' << v[v.size() - 1] << "]";
	return os;
}


2.1. Перегрузка в глобальном пространстве имен

Пусть, например, в некотором модуле в глобальном пространстве имен определены пользовательские функции:

void* operator new(std::size_t size)
{
// ...
}

void operator delete(void* ptr)
{
// ...
}

В этом случае произойдет фактически подмена (replacement) стандартных функций выделения 
и освобождения памяти для всех вызовов операторов new/delete для любых классов (в том числе и стандартных) 
во всем модуле. Это может привести к полному хаосу. Отметим, что описанный механизм подмены — 
это особый механизм, реализованный только для этого случая, а не какой-то общий механизм C++. 
В этом случае при реализации пользовательских функций выделения и освобождения памяти становится 
невозможным вызов соответствующих стандартных функций, они полностью скрыты (оператор :: не помогает) 
и при попытке их вызвать возникает рекурсивный вызов пользовательской функции.

Определенная в глобальном пространстве имен функция

void* operator new(std::size_t size, const std::nothrow_t& nth)
{
// ...
}

также подменит стандартную, но потенциальных проблем будет меньше, потому что не выбрасывающего
исключений оператор new используется редко. Но стандартная форма также недоступна.

Такая же ситуация с функциями для массивов.

Перегрузка операторов new/delete в глобальном пространстве имен настоятельно не рекомендуется.

2.2. Перегрузка в классе

Перегрузка операторов new/delete в классе лишена описанных выше недостатков. 
Перегрузка действует только при создании и удалении экземпляров соответствующего 
класса независимо от контекста вызова операторов new/delete. При реализации пользовательских 
функций выделения и освобождения памяти с помощью оператора :: можно получить доступ к соответствующим 
стандартным функциям. Рассмотрим пример.

class X
{
// ...
public:
    void* operator new(std::size_t size)
    {
        std::cout << "X new\n";
        return ::operator new(size);
    }

    void operator delete(void* ptr)
    {
        std::cout << "X delete\n";
        ::operator delete(ptr);
    }

    void* operator new[](std::size_t size)
    {
        std::cout << "X new[]\n";
        return ::operator new[](size);
    }

    void operator delete[](void* ptr)
    {
        std::cout << "X delete[]\n";
        ::operator delete[](ptr);
    }
};

В этом примере к стандартным операциям просто добавляется трассировка. 
Теперь в выражениях new X() и new X[N] будут использоваться эти функции 
для выделения и освобождения памяти.

Эти функции формально являются статическими, и их можно объявлять как static. 
Но по существу они являются экземплярными, с вызова функции operator new() 
начинается создание экземпляра, а вызов функции operator delete() завершает его удаление. 
Эти функции никогда не вызываются для других задач. Более того, как будет показано ниже, 
функция operator delete() по существу является виртуальной. Так что правильнее объявлять их без static.

2.2.1. Доступ к стандартным формам операторов new/delete

Операторы new/delete можно использовать с дополнительным оператором разрешения 
области видимости, например ::new(p) X(). В этом случае функция operator new(), 
определенная в классе, будет игнорироваться, а будет использована соответствующая 
стандартная. Таким же способом можно использовать и оператор delete.

2.2.2. Сокрытие других форм операторов new/delete

Если теперь для класса X мы попробуем использовать размещающий или не выбрасывающий 
исключений new, то получим ошибку. Дело в том что, функция operator new(std::size_t size) 
будет скрывать (hide) другие формы operator new(). Проблему можно решить двумя способами. 
В первом надо добавить соответствующие варианты в класс (эти варианты должны просто 
делегировать операцию стандартной функции). Во втором надо использовать оператор new 
с оператором разрешения области видимости, например ::new(p) X().

2.2.3. Стандартные контейнеры

Если мы попробуем разместить экземпляры X в каком-нибудь стандартном контейнера, 
например std::vector<X>, то увидим, что наши функции для выделения и освобождения 
памяти не используются. Дело в том, что все стандартные контейнеры имеют собственный 
механизм выделения и освобождения памяти (специальный класс-аллокатор, являющийся шаблонным параметром контейнера), 
а для инициализации элементов используют размещающий оператор new.

2.2.4. Наследование

Функции для выделения и освобождения памяти наследуются. Если эти функции определены 
в базовом классе, а в производном нет, то для производного класса также будет перегружены 
операторы new/delete, и будут использованы функции для выделения и освобождения памяти, 
определенные в базовом классе.

Рассмотрим теперь полиморфную иерархию классов, где каждый класс перегружает операторы new/delete. 
Пусть теперь экземпляр производного класса удаляется с помощью оператора delete через указатель 
на базовый класс. Если деструктор базового класса виртуальный, то стандарт гарантирует вызов 
деструктора этого производного класса. В этом случае также гарантируется вызов функции operator delete(), определенной для этого производного класса. Таким образом функция operator delete() фактически является виртуальной.

2.2.5. Альтернативная форма функции operator delete()

В классе (особенно, когда используется наследование) иногда удобно применить альтернативную 
форму функции освобождения памяти:

void operator delete(void* p, std::size_t size);
void operator delete[](void* p, std::size_t size);

Параметр size задает размер элемента (даже в варианте для массива). Такая форма позволяет 
использовать разные функции для выделения и освобождения памяти в зависимости от 
конкретного производного класса.

3. Пользовательские операторы new/delete

C++ может поддержать пользовательские формы оператора new следующего вида:

new(/* аргументы */) T(/* аргументы конструктора */)
new(/* аргументы */) T[/* длина массива */]

Для того, чтобы эти формы были поддержаны, необходимо определить соответствующие функции выделения и освобождения памяти:

void* operator new(std::size_t size, /* доп. параметры */);
void* operator new[](std::size_t size, /* доп. параметры */);
void operator delete(void* p, /* доп. параметры */);
void operator delete[](void* p, /* доп. параметры */);

Список дополнительных параметров функций выделения памяти должен быть не пуст и не состоять 
из одного void* или const std::nothrow_t&, то есть их сигнатура не должна совпадать с одной 
из стандартных. Списки дополнительных параметров в operator new() и operator delete() должны 
совпадать. Аргументы, передаваемые в оператор new, должны соответствовать дополнительным 
параметрам функций выделения памяти. Пользовательская функция operator delete() также может 
быть в форме с дополнительным параметром размера.

Эти функции можно определить в глобальном пространстве имен или в классе, но не в пространстве 
имен, отличном от глобального. Если они определены в глобальном пространстве имен, то они не 
подменяют, а перегружают стандартные функции выделения и освобождения памяти, поэтому их 
использование предсказуемо и безопасно, а стандартные функции всегда доступны. Если они 
определены в классе, то скрывают стандартные формы, но доступ к стандартным формам можно 
получить с помощью оператора ::, это подробно описано в разделе 2.2.



https://habr.com/ru/articles/490640/


















