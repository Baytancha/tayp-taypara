ostream& operator<<(ostream& os, const Book& d)
{
    return os << "title: " << d.title_get() <<"\n"
        << "author: " << d.author_get() << "\n"
        << "ISBN: " << d.ISBN_get() << "\n"
        << "copyright date: " << d.copyright_get() << "\n"
        << "genre: " << genre_name(d) << "\n";
}

//------------------------------------------------------------------------------

istream& operator>>(istream& is, Book& dd)
{
    cout << "Enter title: ";
    string t;
    is >> t;
    cout << "Enter author: ";
    string a;
    is >> a;
    cout << "Enter date: ";
    Date copy;
    is >> copy;
      
    if (!is)  {
        is.clear(ios_base::failbit);                    
        return is;
    }

    dd = Book(t, a, copy);   // update dd
    return is;
}


https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading?noredirect=1&lq=1


operator->() is actually extremely weird. It's not required to return a value_type* -- 
in fact, it can return another class type, provided that class type has an operator->(), 
which will then be called subsequently. This recursive calling of operator->()s proceeds 
until a value_type* return type occurs. Madness! :)














