//all print the same string
char b[] = "Nello";

	std::cout << b << "\n";

	 char* a = b;

	std::cout << a << "\n";

	std::string c = a;

	std::cout << c << "\n";

here's how a dynamic array is created on the heap:
char* p = new char[count];















Explain the difference between the following C++ expressions:

Case 1:
const char* a = "Nello";
std::cout << a;

Case 2:
char* b = "Nello";
std::cout << b;


The difference between the two cases lies in the use of the const keyword
In Case 1, const char* a = "Nello"; declares a pointer to a constant character. 
This means that the characters that a points to cannot be changed through a. 
The string "Nello" is stored in read-only memory, and a points to that. 
If you try to modify the string through a, it will result in undefined behavior.

In Case 2, char* b = "Nello"; declares a pointer to a character. 
This implies that the characters that b points to can be changed. 
However, in C++, string literals like "Nello" are still stored in read-only memory, 
so attempting to modify them will result in undefined behavior. 
This is actually not valid C++ code, even though it may compile and run 
without errors in some compilers due to backward compatibility with C.

In summary, the main difference is that const char* a is a pointer to a constant character 
(you can't change the value of the character), 
while char* b is a pointer to a character (you can change the value of the character). 
However, in both cases, attempting to modify the string literal will result 
in undefined behavior because string literals are stored in read-only memory in C++.





Explain the following C++ code:

char b[] = "Nello";
const char* a = b;

This C++ code is doing two things:


It's declaring a character array b and initializing it with the string "Nello". 
In C++, a string is an array of characters. The last character in the array 
is always the null character (\0), which signifies the end of the string. 
So, the array b actually contains the characters 'N', 'e', 'l', 'l', 'o', and '\0'.
It's declaring a pointer to a constant character a and initializing it 
with the address of the first character of the array b. This means that 
a points to the first character of the string "Nello". The const keyword 
means that the character that a points to cannot be changed through this pointer.
In summary, this code creates a string "Nello" and a pointer to 
the first character of this string. The pointer is declared 
as a pointer to a constant character, which means that 
the character it points to cannot be changed.





Explain the following C++ code:

char b[] = "Nello";
char c[] = {'N','e','l','l','o'}

char b[] = "Nello";
This line is defining a character array b and initializing it 
with the string "Nello". In C++, strings are essentially arrays of characters. 
The null character \0 is automatically appended at the end of the string 
to mark its end. So, b is actually an array of 6 characters: 'N', 'e', 'l', 'l', 'o', and '\0'.

char c[] = {'N','e','l','l','o'};
This line is defining a character array c and initializing it with the characters 
'N', 'e', 'l', 'l', 'o'. Unlike the first line, this array does not automatically 
get a null character at the end. So, c is an array of 5 characters: 
'N', 'e', 'l', 'l', 'o'.

In summary, both b and c are character arrays that store the string 
"Nello", but b includes the null character at the end, while c does not.








char d[] = "	DEGRADATION GA lore TODAY";

	 const char* zz = d;
	 char* ddd = zz; // char* can't refer to the object pointer to by const char even though it'd located on the stack


char* zz = d;
char* ddd = zz; // it's alright, chat* ddd points to  the stack object that char* zz also points to 



















