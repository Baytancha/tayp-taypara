
template<typename D>
struct PropertyHelper
{
    Property Prop(char const* name, int initial)
    { return Property(name, initial, static_cast<D*>(this)); }
};

struct Widget : Object, PropertyHelper<Widget>
{
    Property Height{ Prop("Height", 10) };
    Property Width{ Prop("Width", 10) };
};






struct Object
{

///other methods elided


Property Prop(char const* name, int initial)
    { return Property(name, initial, this); }

};

struct Widget : Object
{
    Property Height{ Prop("Height", 10) };
    Property Width{ Prop("Width", 10) };
};




Can you tell me if this wouldn't work, and why? Wouldn't the Property Prop function directly get the pointer to the base object Object without the need for templates and conversions?




So when we create an object Widget x, a base object Object and a base object PropertyHelper<Widget> with their own addresses are created underneath it, and the this pointer in x points to all those base classes as well, is that correct?

Not quite. The base classes aren't separate objects, they are the same object. Given a class B that inherits from class A. Rather than creating an object B that owns an object A, what actually happens is that B is an object that contains all of its own members and methods, while also containing all of the members and methods of class A. Think of B as a superset of A, that can use the methods / members from both A and B.

But because with PropertyHelper<Widget> we don't actually pass the address of the x anywhere but just instantiate the template, we need some way to pass the information about x to the Property Prop function, so that it would ''find'' the correct pointer. We do so by making it convert from the this pointer to the base class object to the pointer of the object itself. And because PropertyHelper<Widget> is a base object of x and thus 'tied to it', the compiler deduces wher the object is by converting from the base. Is that it?

The code above isn't "finding" any pointers. What's happening here is that we are changeing the way we interpret the memory of the this pointer by calling static_cast

A pointer is just an address in memory, nothing more. The type that we interpret the pointer as is used as a guide for how to read that memory. So a pointer of type "Widget" would know that the object being pointed to is sizeof(Widget) and what offsets it needs to apply to the pointer address to access it's members ect.

While we are inside a member method of the base class, the process only knows about the direct class that we are inside of. So calling this when inside PropertyHelper<Widget> will return PropertyHelper<Widget>*. But here's the thing, the object that we are calling this method on may actually be a subclass of PropertyHelper<Widget> such as Widget.

Here's where this code gets clever. Because you have no way of knowing which subclass this is, if any. They have added the type of the child class as a template parameter to PropertyHelper. So you know that a PropertyHelper<Widget> has a subclass of type Widget. This code makes the assumption that no one would inherit from PropertyHelper<Widget> with a different class. But it is not enforced and could be misused, resulting in bad casts that result in garbage data (if the pointer was interpreted as the wrong type, it would make no sense)

I have simplified how this works somewhat, by explaining everything as if there were only single inheritance occuring. The existence of Object complicates matters but the other comments have already explained why that is fine and it is not important for this specific answer.







struct Object;


struct Property
{
	Property(char const* name, int initial, Object* owner) :
		m_name(name), m_value(initial), m_owner(owner) {}

	char const* m_name;
	Object* m_owner;
	int m_value;
};


struct Object
{
	Property Prop(char const* name, int initial)
	{
		return Property(name, initial, this);
	}
	///other methods elided


};


struct Widget : Object
{

	Property Height{ Prop("Height", 10) };
	Property Width{ Prop("Width", 10) };
};




int main()
try {


	Widget x;

	Property z = x.Prop("bork", 12);

	std::cout << x.Height.m_owner << "\n";

	std::cout << &x << "\n";

	return 0;

}
catch (std::exception& e) {
	std::cerr << e.what() << '\n';
}
catch (...) {
	std::cerr << "something bad happened\n";
}














