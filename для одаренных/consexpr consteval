To be eligible for compile-time evaluation, a function must have a constexpr return type and not call any non-constexpr functions when evaluated at compile-time. 
Additionally, a call to the function must have constexpr arguments (e.g. constexpr variables or literals).


NB: PARAMETERS IN A CONSTEXPR FUNCTION HAVE TO BE NORMAL BECAUSE WE DON'T KNOW IF A CONSTEXPR OR NON-CONSTEXPR ARGUMENT WILL BE PASSED TO THE FUNCTION
AND THE COMPILER CAN'T CHECK SOMETHING THAY MAY OR MAY NOT BE CONSTEPR (AND YOU ALSO CAN'T ENFORCE A CONSTEXPR-ONLY VERSION OF A FUNCTION)









Use consteval if you have a function that must run at compile-time for some reason (e.g. performance).
Unless you have a specific reason not to, a function that can be made constexpr generally should be made constexpr.


1) constexpr - for optionality bw compile and runtime
2) consteval - compile time only
3) consteval auto wrapper - both runtime and compile plus compile in a non const context 

#include <iostream>

constexpr int greater(int x, int y) // constexpr argument BUT non-constexpr parameter
{
//x or y can't be evaluated at compile time or statically asserted
    return (x > y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };            // case 1: evaluated at compile-time
    std::cout << g << " is greater!\n";

    int x{ 5 }; // not constexpr
    std::cout << greater(x, 6) << " is greater!\n"; // case 2: evaluated at runtime

    std::cout << greater(5, 6) << " is greater!\n"; // case 3: may be evaluated at either runtime or compile-time

    return 0;
}


#include <iostream>

consteval int greater(int x, int y) // function is now consteval
{
    return (x > y ? x : y);
}

int main()
{
    constexpr int g { greater(5, 6) };              // ok: will evaluate at compile-time
    std::cout << g << '\n';

    std::cout << greater(5, 6) << " is greater!\n"; // ok: will evaluate at compile-time

    int x{ 5 }; // not constexpr
    std::cout << greater(x, 6) << " is greater!\n"; // error: consteval functions must evaluate at compile-time

    return 0;
}



#include <iostream>

// Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value
// See 'related content' box below for more info (you don't need to know how these work to use this function)
consteval auto compileTime(auto value)
{
    return value;
}

constexpr int greater(int x, int y) // function is constexpr
{
    return (x > y ? x : y);
}

int main()
{
    std::cout << greater(5, 6) << '\n';              // may or may not execute at compile-time
    std::cout << compileTime(greater(5, 6)) << '\n'; // will execute at compile-time

    int x { 5 };
    std::cout << greater(x, 6) << '\n';              // we can still call the constexpr version at runtime if we wish

    return 0;
}



Constexpr/consteval function parameters are not constexpr (but can be used as arguments to other constexpr functions)

The parameters of a constexpr function are not constexpr (and thus cannot be used in constant expressions). 
Such parameters can be declared as const (in which case they are treated as runtime constants), but not constexpr. 
This is because a constexpr function can be evaluated at runtime (which wouldn’t be possible if the parameters were compile-time constants).

However, an exception is made in one case: a constexpr function can pass those parameters as arguments to another constexpr function, 
and that subsequent constexpr function can be resolved at compile-time. This allows constexpr functions to still be resolved at 
compile-time when they call other constexpr functions (including themselves recursively).

Perhaps surprisingly, the parameters of a consteval function are not considered to be constexpr within the function either 
(even though consteval functions can only be evaluated at compile-time). This decision was made for the sake of consistency.



#include <iostream>

constexpr int goo(int c)
{
    return c;
}

constexpr int foo(int b)
{
    constexpr int b2 { b }; // compile error: b is not a constant expression within foo()

    return goo(b);          // okay: b can still be used as argument to constexpr function goo()
}

int main()
{
    constexpr int a { 5 };

    std::cout << foo(a); // okay: constant expression a can be used as argument to constexpr function foo()

    return 0;
}


















Because constexpr functions may be evaluated at compile-time, the compiler must be able to see the full definition of the constexpr 
function at all points where the function is called. A forward declaration will not suffice, even if the actual function definition 
appears later in the same compilation unit.

This means that a constexpr function called in multiple files needs to have its definition included into each such file -- 
  which would normally be a violation of the one-definition rule. To avoid such problems, constexpr functions are implicitly 
inline, which makes them exempt from the one-definition rule.

As a result, constexpr functions are often defined in header files, so they can be #included into any .cpp file that requires the full definition.
Consteval functions are also implicitly inline for the same reasons.



The C++ standard says that a constexpr function must return a constexpr value for at least one set of arguments, otherwise it is technically ill-formed. 
  Therefore, calling a non-constexpr function unconditionally in a constexpr function makes the constexpr function ill-formed. However, compilers are 
not required to generate errors or warnings for such cases -- therefore, the compiler probably won’t complain unless you try to call such a constexpr function in a constant context.

Therefore, we’d advise the following:

For best results, avoid calling non-constexpr functions from within a constexpr function if possible.
If your constexpr function requires different behavior for constant and non-constant contexts, 
conditionalize the behavior with if (std::is_constant_evaluated()).
Always test your constexpr functions in a constant context, as they may work when called in a non-constant 
context but fail in a constant context.















Non-type template parameters are used primarily when we need to pass constexpr values to functions (or class types) 
so they can be used in contexts that require a constant expression.

The class type std::bitset uses a non-type template parameter to define the number of bits to store because 
the number of bits must be a constexpr value.

Having to use non-type template parameters to circumvent the restriction that function parameters can’t be 
constexpr isn’t great. There are quite a few different proposals being evaluated to help address situations like this. 
I expect that we might see a better solution to this in a future C++ language standard.


#include <cmath> // for std::sqrt
#include <iostream>

template <double D> // requires C++20 for floating point non-type parameters
double getSqrt()
{
    static_assert(D >= 0.0, "getSqrt(): D must be non-negative");

    if constexpr (D >= 0) // ignore the constexpr here for this example
        return std::sqrt(D); // strangely, std::sqrt isn't a constexpr function (until C++26)

    return 0.0;
}

int main()
{
    std::cout << getSqrt<5.0>() << '\n';
    std::cout << getSqrt<-5.0>() << '\n';

    return 0;
}
















